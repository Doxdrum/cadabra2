<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cadabra: Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cadabra
   </div>
   <div id="projectbrief">Computer algebra system for field theory problems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(13)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Core</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Module Description</h2>
<p>All computer algebra functionality in the form of C++ classes. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__display"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__display.html">Cleanup</a></td></tr>
<tr class="memdesc:group__display"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functionality to clean up expressions so that they satisfy the requirements of a consistent expression tree. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__compare"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__compare.html">Expression comparison</a></td></tr>
<tr class="memdesc:group__compare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions to compare and match expressions stored in exptree objects. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__pythoncore"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pythoncore.html">Python Core</a></td></tr>
<tr class="memdesc:group__pythoncore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Python wrapper around the C++ core module, making the entire functionality of <a class="el" href="classCadabra.html" title="The Cadabra notebook application. ">Cadabra</a> accessible from Python. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__scalar"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar.html">Scalar algebra</a></td></tr>
<tr class="memdesc:group__scalar"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functionality to make <a class="el" href="classCadabra.html" title="The Cadabra notebook application. ">Cadabra</a> interface with the SymPy computer algebra system. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__algorithms"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algorithms.html">Algorithms</a></td></tr>
<tr class="memdesc:group__algorithms"><td class="mdescLeft">&#160;</td><td class="mdescRight">Containing all algorithms acting on symbolic expression trees. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__properties"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__properties.html">Properties</a></td></tr>
<tr class="memdesc:group__properties"><td class="mdescLeft">&#160;</td><td class="mdescRight">Containing all properties that can be attached to symbolic expressions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlgorithm.html">Algorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all algorithms, containing generic routines and in particular the logic for index classification.  <a href="classAlgorithm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classindex__iterator.html">index_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator which iterates over indices even if they are at lower levels, i.e.  <a href="classindex__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classParser.html" title="Parser module, which takes the string output of the preprocessor.hh module and turns it into an Ex ex...">Parser</a> module, which takes the string output of the preprocessor.hh module and turns it into an <a class="el" href="classEx.html" title="Basic storage class for symbolic mathemematical expressions. ">Ex</a> expression tree.  <a href="classParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPermutationException.html">PermutationException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic permutation group material.  <a href="classPermutationException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpreprocessor.html">preprocessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocessing class which takes infix mathematical notation with all sorts of maths shortcuts and transforms it into a string which is properly formatted in prefix notation.  <a href="classpreprocessor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproperty.html">property</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all properties, handling argument parsing and defining the interface.  <a href="classproperty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classProperties.html">Properties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding a collection of properties attached to expressions.  <a href="classProperties.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstr__node.html">str_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementary building block for a mathematical expression.  <a href="classstr__node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEx.html">Ex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic storage class for symbolic mathemematical expressions.  <a href="classEx.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnset__it__less.html">nset_it_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two nset iterators by comparing the strings to which they point.  <a href="classnset__it__less.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependsBase.html">DependsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga35b10c93cc5ba450134878a3cda1e10d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga35b10c93cc5ba450134878a3cda1e10d">operator&lt;</a> (const Ex::iterator &amp;, const Ex::iterator &amp;)</td></tr>
<tr class="memdesc:ga35b10c93cc5ba450134878a3cda1e10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic comparison operator for tree iterators, so we can use them as keys in maps.  <a href="#ga35b10c93cc5ba450134878a3cda1e10d">More...</a><br/></td></tr>
<tr class="separator:ga35b10c93cc5ba450134878a3cda1e10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c0d915d27dbcdf1aa070153a3e608b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga5c0d915d27dbcdf1aa070153a3e608b0">cadabra::do_list</a> (const <a class="el" href="classEx.html">Ex</a> &amp;tr, Ex::iterator it, std::function&lt; bool(Ex::iterator)&gt; f)</td></tr>
<tr class="memdesc:ga5c0d915d27dbcdf1aa070153a3e608b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on every element of a list, or if the iterator 'it' does not point to a list, only on that single element.  <a href="#ga5c0d915d27dbcdf1aa070153a3e608b0">More...</a><br/></td></tr>
<tr class="separator:ga5c0d915d27dbcdf1aa070153a3e608b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4e698e597f52dc43f1e3ca8414a959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga9b4e698e597f52dc43f1e3ca8414a959">cadabra::do_subtree</a> (const <a class="el" href="classEx.html">Ex</a> &amp;tr, Ex::iterator it, std::function&lt; void(Ex::iterator)&gt; f)</td></tr>
<tr class="separator:ga9b4e698e597f52dc43f1e3ca8414a959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2ae6b908d34ea0490114559107ede5"><td class="memItemLeft" align="right" valign="top">Ex::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga3a2ae6b908d34ea0490114559107ede5">cadabra::find_in_list</a> (const <a class="el" href="classEx.html">Ex</a> &amp;tr, Ex::iterator it, std::function&lt; Ex::iterator(Ex::iterator)&gt; f)</td></tr>
<tr class="memdesc:ga3a2ae6b908d34ea0490114559107ede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element for which 'f' does not return tr.end().  <a href="#ga3a2ae6b908d34ea0490114559107ede5">More...</a><br/></td></tr>
<tr class="separator:ga3a2ae6b908d34ea0490114559107ede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad925ab5545854ee596c218738f11b013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEx.html">Ex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gad925ab5545854ee596c218738f11b013">cadabra::make_list</a> (<a class="el" href="classEx.html">Ex</a> el)</td></tr>
<tr class="memdesc:gad925ab5545854ee596c218738f11b013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the tree is a list, even if it contains only a single element.  <a href="#gad925ab5545854ee596c218738f11b013">More...</a><br/></td></tr>
<tr class="separator:gad925ab5545854ee596c218738f11b013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2a0c5f8749e25b136df72748e13363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#gaff2a0c5f8749e25b136df72748e13363">pre_clean_dispatch</a> (const <a class="el" href="classKernel.html">Kernel</a> &amp;<a class="el" href="passing_8cc.html#ab66ed8e0098c0a86b458672a55a9cca9">k</a>, <a class="el" href="classEx.html">Ex</a> &amp;, Ex::iterator &amp;it)</td></tr>
<tr class="memdesc:gaff2a0c5f8749e25b136df72748e13363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle the entire preclean stage, which turns a parsed expression into an expression which satisfies the <a class="el" href="classCadabra.html" title="The Cadabra notebook application. ">Cadabra</a> conventions:  <a href="#gaff2a0c5f8749e25b136df72748e13363">More...</a><br/></td></tr>
<tr class="separator:gaff2a0c5f8749e25b136df72748e13363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac55b1d1d20bb0352a5815c9e0a494c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga1ac55b1d1d20bb0352a5815c9e0a494c">multiply</a> (rset_t::iterator &amp;, <a class="el" href="Storage_8hh.html#aad74ea408f31d2d673c876764301e245">multiplier_t</a>)</td></tr>
<tr class="memdesc:ga1ac55b1d1d20bb0352a5815c9e0a494c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions for manipulation of multipliers.  <a href="#ga1ac55b1d1d20bb0352a5815c9e0a494c">More...</a><br/></td></tr>
<tr class="separator:ga1ac55b1d1d20bb0352a5815c9e0a494c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509576f4c5f41edf421f0d88ebfc4902"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core.html#ga509576f4c5f41edf421f0d88ebfc4902">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classEx.html">Ex</a> &amp;)</td></tr>
<tr class="memdesc:ga509576f4c5f41edf421f0d88ebfc4902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bare output operator for <a class="el" href="classEx.html" title="Basic storage class for symbolic mathemematical expressions. ">Ex</a> objects, mainly to provide a simple way to generate debugging output.  <a href="#ga509576f4c5f41edf421f0d88ebfc4902">More...</a><br/></td></tr>
<tr class="separator:ga509576f4c5f41edf421f0d88ebfc4902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5c0d915d27dbcdf1aa070153a3e608b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cadabra::do_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEx.html">Ex</a> &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ex::iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(Ex::iterator)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function on every element of a list, or if the iterator 'it' does not point to a list, only on that single element. </p>
<p>Handles lists wrapped in an  node as well. It is safe to remove the node pointed to by 'it' in 'f'. If your 'f' returns false, the loop is aborted immediately. </p>

</div>
</div>
<a class="anchor" id="ga9b4e698e597f52dc43f1e3ca8414a959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cadabra::do_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEx.html">Ex</a> &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ex::iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(Ex::iterator)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a function on every node in the tree below the given node, depth-first. </p>

</div>
</div>
<a class="anchor" id="ga3a2ae6b908d34ea0490114559107ede5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ex::iterator cadabra::find_in_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEx.html">Ex</a> &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ex::iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Ex::iterator(Ex::iterator)&gt;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first element for which 'f' does not return tr.end(). </p>

</div>
</div>
<a class="anchor" id="gad925ab5545854ee596c218738f11b013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEx.html">Ex</a> cadabra::make_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEx.html">Ex</a>&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the tree is a list, even if it contains only a single element. </p>

</div>
</div>
<a class="anchor" id="ga1ac55b1d1d20bb0352a5815c9e0a494c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void multiply </td>
          <td>(</td>
          <td class="paramtype">rset_t::iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Storage_8hh.html#aad74ea408f31d2d673c876764301e245">multiplier_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions for manipulation of multipliers. </p>

</div>
</div>
<a class="anchor" id="ga35b10c93cc5ba450134878a3cda1e10d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Ex::iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ex::iterator &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic comparison operator for tree iterators, so we can use them as keys in maps. </p>

</div>
</div>
<a class="anchor" id="ga509576f4c5f41edf421f0d88ebfc4902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEx.html">Ex</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bare output operator for <a class="el" href="classEx.html" title="Basic storage class for symbolic mathemematical expressions. ">Ex</a> objects, mainly to provide a simple way to generate debugging output. </p>
<p>Does not do any fancy formatting; just prints a nested list representation. For more fancy output, look at <a class="el" href="classDisplayTeX.html" title="Class to handle display of expressions using LaTeX notation. ">DisplayTeX</a>, <a class="el" href="classDisplaySympy.html" title="Class to display expressions in a format that Sympy can parse. ">DisplaySympy</a> and <a class="el" href="classDisplayTerminal.html" title="Class to display expressions to the terminal. ">DisplayTerminal</a>. </p>

</div>
</div>
<a class="anchor" id="gaff2a0c5f8749e25b136df72748e13363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pre_clean_dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classKernel.html">Kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEx.html">Ex</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ex::iterator &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle the entire preclean stage, which turns a parsed expression into an expression which satisfies the <a class="el" href="classCadabra.html" title="The Cadabra notebook application. ">Cadabra</a> conventions: </p>
<ul>
<li>All numerical multipliers in a product on the product node, no multiplier on a sum node.</li>
<li>Any '\frac' nodes with a purely numerical denominator should be rewritten as a rational multiplier for the numerator node.</li>
<li><a class="el" href="classDerivative.html">Derivative</a> nodes can have an arbitrary number of index child nodes and must have at least one function child node. The first function node is interpreted as the argument on which the derivative(s) act. All other nodes indicate with respect to which object or variable the derivatives are taken. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 2 2016 11:58:01 for Cadabra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
